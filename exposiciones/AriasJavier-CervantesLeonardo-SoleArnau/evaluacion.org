#+title:  Evaluaci√≥n de la exposici√≥n
#+author: Gunnar Wolf

* Concurrencia en la programaci√≥n funcional

- Tema presentado por :: Leonardo Mikel Cervantes, Arnau Roger Sol√© y Javier Arias
- Calificaci√≥n global :: Por favor lean todo el archivo para entender de d√≥nde
  vienen todos estos n√∫meros üòâ

|------------------------+------+--------------------+------+---------|
| Evaluaci√≥n  compa√±eros | Peso | Evaluaci√≥n docente | Peso | *Total* |
|------------------------+------+--------------------+------+---------|
|                   8.44 |  0.3 |                9.1 |  0.7 |    8.90 |
|------------------------+------+--------------------+------+---------|
#+TBLFM: @2$5=$1*$2+$3*$4;f-2

* Comentarios

Dado que es una presentaci√≥n en video, no puedo evaluar /dominio del tema/ y
/presencia/ como lo har√≠amos habitualmente. Me centro en las respuestas que
hagan a las preguntas de sus compa√±eros para el primero y en si la presentaci√≥n
"suena" le√≠da directamente del material que prepararon o expuesta m√°s libremente
para el segundo.


* Evaluaci√≥n grupal

|              | 1 | 2 | 3 | 4 | 5 | Total |
|--------------+---+---+---+---+---+-------|
| Originalidad | 0 | 0 | 2 | 3 | 4 |  8.44 |
| Nivel        | 0 | 0 | 2 | 2 | 5 |  8.67 |
| Relevancia   | 0 | 0 | 0 | 3 | 6 |  9.33 |
| Claridad     | 0 | 0 | 3 | 2 | 4 |  8.22 |
| Presencia    | 0 | 1 | 2 | 4 | 2 |  7.56 |
|--------------+---+---+---+---+---+-------|
|              |   |   |   |   |   |  8.44 |
#+TBLFM: @2$7..@6$7=10 * (0.2*$2 + 0.4*$3 + 0.6*$4 + 0.8*$5 + $6 ) / vsum($2..$6); f-2::@7$7=vmean(@2$7..@6$7); f-2

** Comentarios de los compa√±eros

Su exposici√≥n recibi√≥ los siguientes comentarios anonimizados por
parte de sus compa√±eros:

- Un tema muy interesante y muy poco conocido para mi, considero que la
  informacion e ejemplos fueron de gran utilidad. Solo diria que el
  compa√±ero Mikel le costo un poco el explicar, se comprende el nerviosismo
  del grabar un video hablando de este tipo de temas, pero fuera de eso, la
  expo fue muy interesante.

* Evaluaci√≥n por parte del docente

| *Aspecto*                          | *Peso* | *Evaluaci√≥n* | *Puntos* |
|------------------------------------+--------+--------------+----------|
| Contenido t√©cnico y profundidad    |    0.3 |           10 |       3. |
| Fuentes bibliogr√°ficas             |   0.15 |            7 |     1.05 |
| Organizaci√≥n                       |   0.15 |           10 |      1.5 |
| Comunicaci√≥n oral y uso del tiempo |   0.25 |           10 |      2.5 |
| Uso de recursos visuales           |   0.15 |            7 |     1.05 |
|------------------------------------+--------+--------------+----------|
| *Global*                           |        |              |     9.10 |
#+TBLFM: @<<$4..@>>$4=$2*$3::$4=vsum(@<<..@>>);f-2

** Comentarios del docente
- Su presentaci√≥n es muy interesante. Por la fluidez en la explicaci√≥n, me
  parece claro que Arnau es, de los tres, quien m√°s se ha compenetrado con
  el tema; los otros dos compa√±eros explican bien los conceptos, pero se
  ‚Äúatoran‚Äù un poco.
- La parte de la presentaci√≥n que hace Mikel qued√≥ a muy baja resoluci√≥n, y
  dado el tama√±o del c√≥digo que presentan, en varias de las l√°minas no se
  alcanza a entender el c√≥digo que va explicando el compa√±ero üôÅ
- Quisiera agregar a lo que presentan: Otra caracter√≠stica de la
  programaci√≥n funcional que lleva a un mayor uso de memoria es que, dado
  que los resultados de las /funciones puras/ es por definici√≥n /estable/,
  el modo de operaci√≥n habitual de varios compiladores de este tipo
  incluyen hacer una especie de cach√© de resultados de las funciones, de
  forma que llamadas reiteradas a una funci√≥n con el mismo valor no lo
  vuelvan a calcular.

  Por poner un ejemplo (en un lenguaje que /no es funcional/ y cuyas
  funciones /no son puras/), consideren el c√°lculo de la secuencia de
  Fibonacci en Python:
  #+begin_src python
    def fib(n):
        if not(isinstance(n, int)) or n < 0:
            raise(RuntimeError, 'Debe invocarse con un entero positivo')
        if n==0 or n==1:
            return 1
        return fib(n-1) + fib(n-2)
  #+end_src
  La implementaci√≥n es correcta, pero la recursi√≥n hace que =fib(20)= ya
  demore lo suficiente para que sea (apenas) perceptible, y =fib(30)=
  demora un segundo (y el crecimiento... es rapido). Sin embargo, asumiendo
  que =fib(n)= se comporta como una funci√≥n pura:
  #+begin_src python
    res_de_fib = {}
    def fib(n):
        if not(isinstance(n, int)) or n < 0:
            raise(RuntimeError, 'Debe invocarse con un entero positivo')
        if n in res_de_fib:
            return res_de_fib[n]
        if n==0 or n==1:
            return 1
        res_de_fib[n] = fib(n-1) + fib(n-2)
        return res_de_fib[n]
  #+end_src
  Los resultados incluso de n√∫meros grandes se entregan pr√°cticamente de
  inmediato, porque /se resolvi√≥ la recurrencia/ (a costa, claro, de un
  peque√±o uso de memoria).
